package dcs.aber.ac.uk.csm2020_group_3.RecommendationSystem;

import java.util.ArrayList;

/**
 * Class that sorts modules - from those selected in UI to those from Generators - and stores them.
 * (not modules stored in DB)
 */
public abstract class ModuleHandler {

    public Integer test;

    private static Integer currentModuleAmount;
    public static ArrayList<Module> newlyAddedModules;
    private static Integer credits;

    public ModuleHandler(){
        year0Modules = new ArrayList<>();
        year1Modules = new ArrayList<>();
        year2Modules = new ArrayList<>();
        year3Modules = new ArrayList<>();
        year4Modules = new ArrayList<>();
        currentModuleAmount = 0;
        newlyAddedModules = new ArrayList<>();

    }

    public static ArrayList<Module> year0Modules;
    public static ArrayList<Module> year1Modules;
    public static ArrayList<Module> year2Modules;
    public static ArrayList<Module> year3Modules;
    public static ArrayList<Module> year4Modules;

    public void updateModuleAmount(Module elective){
        currentModuleAmount = year0Modules.size() + year1Modules.size() + year2Modules.size() + year3Modules.size() + year4Modules.size();
        newlyAddedModules.add(elective);
    }

    public Integer getModuleAmount(){
        return currentModuleAmount;
    }

    public void setNewlyAddedModulesZero() {
        newlyAddedModules = new ArrayList<>();
    }


    /**
     * Sorts modules generated by CoreListGenerators, or provided by UI.
     * Overloaded method that works on singular or a list of Module objects.
     */
    public Boolean sortModules(Module module) {

        // check year and then append to respective list
        if (module.getYear() == 0) {
            year0Modules.add(module);
            updateModuleAmount(module);

        }
        if (module.getYear() == 1) {
            year1Modules.add(module);
            updateModuleAmount(module);

        }
        if (module.getYear() == 2) {
            year2Modules.add(module);
            updateModuleAmount(module);

        }
        if (module.getYear() == 3) {
            year3Modules.add(module);
            updateModuleAmount(module);

        }
        if (module.getYear() == 4) {
            year4Modules.add(module);
            updateModuleAmount(module);

        }

        return Boolean.FALSE;
    }
    public Boolean sortModules(ArrayList<Module> modules) {
        // iterate through list of module info items
        for (Module module : modules) {

            // check year and then append to respective list
            if (module.getYear() == 0) {
                year0Modules.add(module);
                updateModuleAmount(module);

            }
            if (module.getYear() == 1) {
                year1Modules.add(module);
                updateModuleAmount(module);

            }
            if (module.getYear() == 2) {
                year2Modules.add(module);
                updateModuleAmount(module);

            }
            if (module.getYear() == 3) {
                year3Modules.add(module);
                updateModuleAmount(module);

            }
            if (module.getYear() == 4) {
                year4Modules.add(module);
                updateModuleAmount(module);

            }
        }

        return Boolean.FALSE;
    }

    /**
     * Function that the sortModules function uses to check if credit limit is reached per semester
     * before adding electives to the yearXModule lists.
     * Returns Bool depending on whether credit limit is reached.
     */
    public Boolean checkCredits(ArrayList<Module> moduleList, Integer creditLimit){

        // counter variable
        credits = 0;

        // iterate through modules, get credits
        for (Module module : moduleList) {
            credits += module.getCredits();
        }

        // check if higher than creditLimit
        if (credits > creditLimit){
            return Boolean.FALSE;
        }
        else{
            return Boolean.TRUE;
        }
        //
    }

    /**
     * Module that takes an elective, checks whether it has prerequisites, if so, adds to them current modules lists.
     * Then runs check on that added module if it also has prerequisites.
     * Saves amount of modules to variables for use in WeightGenerator functions.
     * @param elective
     */
    public void checkPrerequisites(Module elective){
        newlyAddedModules = new ArrayList<>();

        // check if module has a prerequisite
        if (!elective.getPrerequisite().equals("")) {

            // check for prerequisite in electiveLists, if's not in electiveList it's either already in selectedList
            //or not possible
            for (int i = 0; i < ElectiveListGenerator.electiveModulesList.size(); i++){

                // after prereq. found in list
                if (elective.getPrerequisite().equals(ElectiveListGenerator.electiveModulesList.get(i).getPrerequisite())){

                        // run check on newly added module, update moduleAmount
                        checkPrerequisites(ElectiveListGenerator.electiveModulesList.get(i));
                        updateModuleAmount(elective);
                    }



                }
            }

        }


    }




